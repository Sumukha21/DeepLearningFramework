from Utils.utils import instance_generator


class Training:
    """
    Runs the training with the provided model on the data generated by the provided data generators
    """
    def __init__(self, epochs, optimizer, loss, callbacks=None, loss_weights=None, steps=None):
        self.epochs = epochs
        self.steps = steps
        self.optimizer = instance_generator(**optimizer)
        self.loss = self.loss_generator(loss)
        self.callbacks = self.callback_generator(callbacks)
        self.loss_weights = loss_weights

    @staticmethod
    def loss_generator(losses_def):
        if isinstance(losses_def, list):
            losses = []
            for loss in losses_def:
                if loss.get("function"):
                    loss_obj = instance_generator(**loss)
                    losses.append(loss_obj(**loss["params"]))
                else:
                    losses.append(instance_generator(**loss))
            return losses
        elif isinstance(losses_def, dict):
            losses = dict()
            for loss_name in list(losses_def.keys()):
                loss = losses_def.get(loss_name)
                if loss.get("function"):
                    loss_obj = instance_generator(**loss)
                    losses[loss_name] = loss_obj(**loss["params"])
                else:
                    losses[loss_name] = instance_generator(**loss)
            return losses
        else:
            if losses_def.get("function"):
                loss_obj = instance_generator(**losses_def)
                return loss_obj(**losses_def["params"])
            else:
                return instance_generator(**losses_def)

    @staticmethod
    def callback_generator(callbacks_def):
        if callbacks_def is not None:
            if isinstance(callbacks_def, list):
                callbacks = []
                for callback in callbacks_def:
                    if callback.get("function"):
                        callback_obj = instance_generator(**callback)
                        callbacks.append(callback_obj(**callback["params"]))
                    else:
                        callbacks.append(instance_generator(**callback))
                return callbacks
            elif isinstance(callbacks_def, dict):
                callbacks = dict()
                for callback_name in list(callbacks_def.keys()):
                    callback = callbacks_def.get(callback_name)
                    if callback.get("function"):
                        callback_obj = instance_generator(**callback)
                        callbacks[callback_name] = (callback_obj(**callback["params"]))
                    else:
                        callbacks[callback_name] = (instance_generator(**callback))
                    return callbacks
            else:
                if callbacks_def.get("function"):
                    callback_obj = instance_generator(**callbacks_def)
                    return callback_obj(**callbacks_def["params"])
                else:
                    return instance_generator(**callbacks_def)

    def __call__(self, model, training_data_generator, validation_data_generator):
        model.compile(optimizer=self.optimizer, loss=self.loss, loss_weights=self.loss_weights)
        if self.steps is not None:
            model.fit(training_data_generator, epochs=self.epochs, callbacks=self.callbacks,
                      validation_data=validation_data_generator, steps_per_epoch=self.steps)
        else:
            model.fit(training_data_generator, epochs=self.epochs, callbacks=self.callbacks,
                      validation_data=validation_data_generator)
